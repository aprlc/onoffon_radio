import {
  blur
} from "./chunk-UYDFXFL5.js";
import "./chunk-M6MB33T7.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  create_bidirectional_transition,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onMount,
  prevent_default,
  prop_dev,
  run_all,
  safe_not_equal,
  set_data_dev,
  set_dynamic_element_data,
  set_style,
  set_svg_attributes,
  space,
  stop_propagation,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_dynamic_element,
  validate_each_argument,
  validate_slots,
  validate_void_dynamic_element
} from "./chunk-RVLVW3YK.js";

// node_modules/svelte-toc/dist/MenuIcon.svelte
var file = "node_modules/svelte-toc/dist/MenuIcon.svelte";
function create_fragment(ctx) {
  let svg;
  let path;
  let svg_levels = [
    /*$$props*/
    ctx[0],
    { viewBox: "0 0 20 20" },
    { fill: "currentColor" }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { viewBox: true, fill: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 5a1 1 0 0 1 1-1h12a1 1 0 1 1 0 2H4a1 1 0 0 1-1-1zm0 5a1 1 0 0 1 1-1h12a1 1 0 1 1 0 2H4a1 1 0 0 1-1-1zm0 5a1 1 0 0 1 1-1h12a1 1 0 1 1 0 2H4a1 1 0 0 1-1-1z");
      add_location(path, file, 2, 2, 129);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file, 1, 0, 68);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & /*$$props*/
        1 && /*$$props*/
        ctx2[0],
        { viewBox: "0 0 20 20" },
        { fill: "currentColor" }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuIcon", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MenuIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuIcon",
      options,
      id: create_fragment.name
    });
  }
};
var MenuIcon_default = MenuIcon;

// node_modules/svelte-toc/dist/Toc.svelte
var { Error: Error_1, console: console_1, window: window_1 } = globals;
var file2 = "node_modules/svelte-toc/dist/Toc.svelte";
function add_css(target) {
  append_styles(target, "svelte-qhrnk4", ".svelte-qhrnk4:where(aside.toc){box-sizing:border-box;height:max-content;overflow-wrap:break-word;font-size:var(--toc-font-size);min-width:var(--toc-min-width);width:var(--toc-width);z-index:var(--toc-z-index, 1)}.svelte-qhrnk4:where(aside.toc > nav){overflow:var(--toc-overflow, auto scroll);overscroll-behavior:contain;max-height:var(--toc-max-height, 90vh);padding:var(--toc-padding, 1em 1em 0)}.svelte-qhrnk4:where(aside.toc > nav > ol){list-style:var(--toc-ol-list-style, none);padding:var(--toc-ol-padding, 0);margin:var(--toc-ol-margin)}.svelte-qhrnk4:where(.toc-title){padding:var(--toc-title-padding);margin:var(--toc-title-margin)}.svelte-qhrnk4:where(aside.toc > nav > ol > li){cursor:pointer;color:var(--toc-li-color);border:var(--toc-li-border);border-radius:var(--toc-li-border-radius);margin:var(--toc-li-margin);padding:var(--toc-li-padding, 2pt 4pt)}.svelte-qhrnk4:where(aside.toc > nav > ol > li:hover){color:var(--toc-li-hover-color, cornflowerblue);background:var(--toc-li-hover-bg)}.svelte-qhrnk4:where(aside.toc > nav > ol > li.active){background:var(--toc-active-bg, cornflowerblue);color:var(--toc-active-color, white);font-weight:var(--toc-active-font-weight);border:var(--toc-active-border);border-width:var(--toc-active-border-width);border-radius:var(--toc-active-border-radius, 2pt)}.svelte-qhrnk4:where(aside.toc > button){border:none;bottom:0;cursor:pointer;font-size:2em;line-height:0;position:absolute;right:0;z-index:2;padding:var(--toc-mobile-btn-padding, 2pt 3pt);border-radius:var(--toc-mobile-btn-border-radius, 4pt);background:var(--toc-mobile-btn-bg, rgba(255, 255, 255, 0.2));color:var(--toc-mobile-btn-color, black)}.svelte-qhrnk4:where(aside.toc > nav){position:relative}.svelte-qhrnk4:where(aside.toc > nav > .toc-title){margin-top:0}.svelte-qhrnk4:where(aside.toc.mobile){position:fixed;bottom:var(--toc-mobile-bottom, 1em);right:var(--toc-mobile-right, 1em)}.svelte-qhrnk4:where(aside.toc.mobile > nav){border-radius:3pt;right:0;z-index:-1;box-sizing:border-box;background:var(--toc-mobile-bg, white);width:var(--toc-mobile-width, 18em);box-shadow:var(--toc-mobile-shadow);border:var(--toc-mobile-border)}.svelte-qhrnk4:where(aside.toc.desktop){margin:var(--toc-desktop-aside-margin)}.svelte-qhrnk4:where(aside.toc.desktop){position:sticky;background:var(--toc-desktop-bg);margin:var(--toc-desktop-nav-margin);max-width:var(--toc-desktop-max-width);top:var(--toc-desktop-sticky-top, 2em)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[41] = list[i];
  child_ctx[42] = list;
  child_ctx[43] = i;
  return child_ctx;
}
var get_toc_item_slot_changes = (dirty) => ({ heading: dirty[0] & /*headings*/
1 });
var get_toc_item_slot_context = (ctx) => ({
  heading: (
    /*heading*/
    ctx[41]
  ),
  idx: (
    /*idx*/
    ctx[43]
  )
});
var get_title_slot_changes = (dirty) => ({});
var get_title_slot_context = (ctx) => ({});
var get_open_toc_icon_slot_changes = (dirty) => ({});
var get_open_toc_icon_slot_context = (ctx) => ({});
function create_if_block_2(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const open_toc_icon_slot_template = (
    /*#slots*/
    ctx[33]["open-toc-icon"]
  );
  const open_toc_icon_slot = create_slot(
    open_toc_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[32],
    get_open_toc_icon_slot_context
  );
  const open_toc_icon_slot_or_fallback = open_toc_icon_slot || fallback_block_2(ctx);
  const block = {
    c: function create() {
      button = element("button");
      if (open_toc_icon_slot_or_fallback)
        open_toc_icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { "aria-label": true, class: true });
      var button_nodes = children(button);
      if (open_toc_icon_slot_or_fallback)
        open_toc_icon_slot_or_fallback.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        button,
        "aria-label",
        /*openButtonLabel*/
        ctx[8]
      );
      attr_dev(button, "class", "svelte-qhrnk4");
      add_location(button, file2, 126, 4, 4639);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (open_toc_icon_slot_or_fallback) {
        open_toc_icon_slot_or_fallback.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", stop_propagation(prevent_default(
          /*click_handler*/
          ctx[35]
        )), false, true, true, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (open_toc_icon_slot) {
        if (open_toc_icon_slot.p && (!current || dirty[1] & /*$$scope*/
        2)) {
          update_slot_base(
            open_toc_icon_slot,
            open_toc_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[32],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[32]
            ) : get_slot_changes(
              open_toc_icon_slot_template,
              /*$$scope*/
              ctx2[32],
              dirty,
              get_open_toc_icon_slot_changes
            ),
            get_open_toc_icon_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*openButtonLabel*/
      256) {
        attr_dev(
          button,
          "aria-label",
          /*openButtonLabel*/
          ctx2[8]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(open_toc_icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(open_toc_icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (open_toc_icon_slot_or_fallback)
        open_toc_icon_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(126:2) {#if !open && !desktop && headings.length >= minItems}",
    ctx
  });
  return block;
}
function fallback_block_2(ctx) {
  let menuicon;
  let current;
  menuicon = new MenuIcon_default({ props: { width: "1em" }, $$inline: true });
  const block = {
    c: function create() {
      create_component(menuicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(menuicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(menuicon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(menuicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menuicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(menuicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(131:33)          ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let nav_1;
  let t;
  let ol;
  let nav_1_transition;
  let current;
  let if_block = (
    /*title*/
    ctx[9] && create_if_block_1(ctx)
  );
  let each_value = (
    /*headings*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      nav_1 = element("nav");
      if (if_block)
        if_block.c();
      t = space();
      ol = element("ol");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      nav_1 = claim_element(nodes, "NAV", { class: true });
      var nav_1_nodes = children(nav_1);
      if (if_block)
        if_block.l(nav_1_nodes);
      t = claim_space(nav_1_nodes);
      ol = claim_element(nav_1_nodes, "OL", { class: true });
      var ol_nodes = children(ol);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ol_nodes);
      }
      ol_nodes.forEach(detach_dev);
      nav_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ol, "class", "svelte-qhrnk4");
      add_location(ol, file2, 144, 6, 5172);
      attr_dev(nav_1, "class", "svelte-qhrnk4");
      add_location(nav_1, file2, 136, 4, 4920);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav_1, anchor);
      if (if_block)
        if_block.m(nav_1, null);
      append_hydration_dev(nav_1, t);
      append_hydration_dev(nav_1, ol);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ol, null);
        }
      }
      ctx[37](nav_1);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*title*/
        ctx[9]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*title*/
          512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(nav_1, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty[0] & /*tocItems, activeHeading, headings, levels, minLevel, handler, getHeadingTitles*/
      598115 | dirty[1] & /*$$scope*/
      2) {
        each_value = /*headings*/
        ctx[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ol, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      add_render_callback(() => {
        if (!current)
          return;
        if (!nav_1_transition)
          nav_1_transition = create_bidirectional_transition(
            nav_1,
            blur,
            /*blurParams*/
            ctx[11],
            true
          );
        nav_1_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      if (!nav_1_transition)
        nav_1_transition = create_bidirectional_transition(
          nav_1,
          blur,
          /*blurParams*/
          ctx[11],
          false
        );
      nav_1_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(nav_1);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      ctx[37](null);
      if (detaching && nav_1_transition)
        nav_1_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(136:2) {#if open || (desktop && headings.length >= minItems)}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[33].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[32],
    get_title_slot_context
  );
  const title_slot_or_fallback = title_slot || fallback_block_1(ctx);
  const block = {
    c: function create() {
      if (title_slot_or_fallback)
        title_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (title_slot_or_fallback)
        title_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty[1] & /*$$scope*/
        2)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[32],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[32]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[32],
              dirty,
              get_title_slot_changes
            ),
            get_title_slot_context
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty[0] & /*titleTag, title*/
        1536)) {
          title_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (title_slot_or_fallback)
        title_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(138:6) {#if title}",
    ctx
  });
  return block;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let t;
  const block = {
    c: function create() {
      svelte_element = element(
        /*titleTag*/
        ctx[10]
      );
      t = text(
        /*title*/
        ctx[9]
      );
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*titleTag*/
        (ctx[10] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      t = claim_text(
        svelte_element_nodes,
        /*title*/
        ctx[9]
      );
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*titleTag*/
        ctx[10]
      )(svelte_element, {
        class: "toc-title toc-exclude svelte-qhrnk4"
      });
      add_location(svelte_element, file2, 139, 10, 5027);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*title*/
      512)
        set_data_dev(
          t,
          /*title*/
          ctx2[9]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: '(140:10) <svelte:element this={titleTag} class=\\"toc-title toc-exclude\\">',
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let previous_tag = (
    /*titleTag*/
    ctx[10]
  );
  let svelte_element_anchor;
  validate_dynamic_element(
    /*titleTag*/
    ctx[10]
  );
  validate_void_dynamic_element(
    /*titleTag*/
    ctx[10]
  );
  let svelte_element = (
    /*titleTag*/
    ctx[10] && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*titleTag*/
        ctx2[10]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*titleTag*/
          ctx2[10];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*titleTag*/
          ctx2[10]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*titleTag*/
            ctx2[10]
          );
          validate_void_dynamic_element(
            /*titleTag*/
            ctx2[10]
          );
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*titleTag*/
          ctx2[10];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*titleTag*/
        ctx2[10];
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(139:27)            ",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t_value = (
    /*getHeadingTitles*/
    ctx[6](
      /*heading*/
      ctx[41]
    ) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*getHeadingTitles, headings*/
      65 && t_value !== (t_value = /*getHeadingTitles*/
      ctx2[6](
        /*heading*/
        ctx2[41]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(156:50)                ",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let li;
  let t;
  let idx = (
    /*idx*/
    ctx[43]
  );
  let style_margin = `0 0 0 ${/*levels*/
  ctx[13][
    /*idx*/
    ctx[43]
  ] - /*minLevel*/
  ctx[16]}em`;
  let style_font_size = `${2 - 0.2 * /*levels*/
  (ctx[13][
    /*idx*/
    ctx[43]
  ] - /*minLevel*/
  ctx[16])}ex`;
  let current;
  let mounted;
  let dispose;
  const toc_item_slot_template = (
    /*#slots*/
    ctx[33]["toc-item"]
  );
  const toc_item_slot = create_slot(
    toc_item_slot_template,
    ctx,
    /*$$scope*/
    ctx[32],
    get_toc_item_slot_context
  );
  const toc_item_slot_or_fallback = toc_item_slot || fallback_block(ctx);
  const assign_li = () => (
    /*li_binding*/
    ctx[36](li, idx)
  );
  const unassign_li = () => (
    /*li_binding*/
    ctx[36](null, idx)
  );
  const block = {
    c: function create() {
      li = element("li");
      if (toc_item_slot_or_fallback)
        toc_item_slot_or_fallback.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { role: true, class: true });
      var li_nodes = children(li);
      if (toc_item_slot_or_fallback)
        toc_item_slot_or_fallback.l(li_nodes);
      t = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "role", "menuitem");
      attr_dev(li, "class", "svelte-qhrnk4");
      toggle_class(
        li,
        "active",
        /*activeHeading*/
        ctx[1] === /*heading*/
        ctx[41]
      );
      set_style(li, "margin", style_margin);
      set_style(li, "font-size", style_font_size);
      add_location(li, file2, 146, 10, 5228);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (toc_item_slot_or_fallback) {
        toc_item_slot_or_fallback.m(li, null);
      }
      append_hydration_dev(li, t);
      assign_li();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            li,
            "click",
            function() {
              if (is_function(
                /*handler*/
                ctx[19](
                  /*heading*/
                  ctx[41]
                )
              ))
                ctx[19](
                  /*heading*/
                  ctx[41]
                ).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keyup",
            function() {
              if (is_function(
                /*handler*/
                ctx[19](
                  /*heading*/
                  ctx[41]
                )
              ))
                ctx[19](
                  /*heading*/
                  ctx[41]
                ).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (toc_item_slot) {
        if (toc_item_slot.p && (!current || dirty[0] & /*headings*/
        1 | dirty[1] & /*$$scope*/
        2)) {
          update_slot_base(
            toc_item_slot,
            toc_item_slot_template,
            ctx,
            /*$$scope*/
            ctx[32],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[32]
            ) : get_slot_changes(
              toc_item_slot_template,
              /*$$scope*/
              ctx[32],
              dirty,
              get_toc_item_slot_changes
            ),
            get_toc_item_slot_context
          );
        }
      } else {
        if (toc_item_slot_or_fallback && toc_item_slot_or_fallback.p && (!current || dirty[0] & /*getHeadingTitles, headings*/
        65)) {
          toc_item_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
        }
      }
      if (idx !== /*idx*/
      ctx[43]) {
        unassign_li();
        idx = /*idx*/
        ctx[43];
        assign_li();
      }
      if (!current || dirty[0] & /*activeHeading, headings*/
      3) {
        toggle_class(
          li,
          "active",
          /*activeHeading*/
          ctx[1] === /*heading*/
          ctx[41]
        );
      }
      if (dirty[0] & /*levels, minLevel*/
      73728 && style_margin !== (style_margin = `0 0 0 ${/*levels*/
      ctx[13][
        /*idx*/
        ctx[43]
      ] - /*minLevel*/
      ctx[16]}em`)) {
        set_style(li, "margin", style_margin);
      }
      if (dirty[0] & /*levels, minLevel*/
      73728 && style_font_size !== (style_font_size = `${2 - 0.2 * /*levels*/
      (ctx[13][
        /*idx*/
        ctx[43]
      ] - /*minLevel*/
      ctx[16])}ex`)) {
        set_style(li, "font-size", style_font_size);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toc_item_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toc_item_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (toc_item_slot_or_fallback)
        toc_item_slot_or_fallback.d(detaching);
      unassign_li();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(146:8) {#each headings as heading, idx}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let aside_1;
  let t;
  let current;
  let mounted;
  let dispose;
  add_render_callback(
    /*onwindowresize*/
    ctx[34]
  );
  let if_block0 = !/*open*/
  ctx[4] && !/*desktop*/
  ctx[2] && /*headings*/
  ctx[0].length >= /*minItems*/
  ctx[7] && create_if_block_2(ctx);
  let if_block1 = (
    /*open*/
    (ctx[4] || /*desktop*/
    ctx[2] && /*headings*/
    ctx[0].length >= /*minItems*/
    ctx[7]) && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      aside_1 = element("aside");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      aside_1 = claim_element(nodes, "ASIDE", { class: true, "aria-hidden": true });
      var aside_1_nodes = children(aside_1);
      if (if_block0)
        if_block0.l(aside_1_nodes);
      t = claim_space(aside_1_nodes);
      if (if_block1)
        if_block1.l(aside_1_nodes);
      aside_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(aside_1, "class", "toc svelte-qhrnk4");
      aside_1.hidden = /*hide*/
      ctx[3];
      attr_dev(
        aside_1,
        "aria-hidden",
        /*hide*/
        ctx[3]
      );
      toggle_class(
        aside_1,
        "desktop",
        /*desktop*/
        ctx[2]
      );
      toggle_class(
        aside_1,
        "hidden",
        /*hide*/
        ctx[3]
      );
      toggle_class(aside_1, "mobile", !/*desktop*/
      ctx[2]);
      add_location(aside_1, file2, 116, 0, 4434);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside_1, anchor);
      if (if_block0)
        if_block0.m(aside_1, null);
      append_hydration_dev(aside_1, t);
      if (if_block1)
        if_block1.m(aside_1, null);
      ctx[38](aside_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window_1,
            "scroll",
            /*set_active_heading*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "click",
            /*close*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "resize",
            /*onwindowresize*/
            ctx[34]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!/*open*/
      ctx2[4] && !/*desktop*/
      ctx2[2] && /*headings*/
      ctx2[0].length >= /*minItems*/
      ctx2[7]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*open, desktop, headings, minItems*/
          149) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(aside_1, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*open*/
        ctx2[4] || /*desktop*/
        ctx2[2] && /*headings*/
        ctx2[0].length >= /*minItems*/
        ctx2[7]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*open, desktop, headings, minItems*/
          149) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(aside_1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*hide*/
      8) {
        prop_dev(
          aside_1,
          "hidden",
          /*hide*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*hide*/
      8) {
        attr_dev(
          aside_1,
          "aria-hidden",
          /*hide*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*desktop*/
      4) {
        toggle_class(
          aside_1,
          "desktop",
          /*desktop*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*hide*/
      8) {
        toggle_class(
          aside_1,
          "hidden",
          /*hide*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*desktop*/
      4) {
        toggle_class(aside_1, "mobile", !/*desktop*/
        ctx2[2]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(aside_1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[38](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let levels;
  let minLevel;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toc", slots, ["open-toc-icon", "title", "toc-item"]);
  let { activeHeading = null } = $$props;
  let { activeHeadingScrollOffset = 100 } = $$props;
  let { activeTocLi = null } = $$props;
  let { breakpoint = 1e3 } = $$props;
  let { desktop = true } = $$props;
  let { flashClickedHeadingsFor = 1500 } = $$props;
  let { getHeadingIds = (node) => node.id } = $$props;
  let { getHeadingLevels = (node) => Number(node.nodeName[1]) } = $$props;
  let { getHeadingTitles = (node) => node.textContent ?? `` } = $$props;
  let { headings = [] } = $$props;
  let { headingSelector = `:is(h2, h3, h4):not(.toc-exclude)` } = $$props;
  let { hide = false } = $$props;
  let { autoHide = true } = $$props;
  let { keepActiveTocItemInView = true } = $$props;
  let { minItems = 0 } = $$props;
  let { open = false } = $$props;
  let { openButtonLabel = `Open table of contents` } = $$props;
  let { pageBody = `body` } = $$props;
  let { scrollBehavior = `smooth` } = $$props;
  let { title = `On this page` } = $$props;
  let { titleTag = `h2` } = $$props;
  let { tocItems = [] } = $$props;
  let { warnOnEmpty = true } = $$props;
  let { blurParams = { duration: 200 } } = $$props;
  let window_width;
  let aside;
  let nav;
  let scroll_id;
  function close(event) {
    if (!aside.contains(event.target))
      $$invalidate(4, open = false);
  }
  function requery_headings() {
    if (typeof document === `undefined`)
      return;
    $$invalidate(0, headings = [...document.querySelectorAll(headingSelector)]);
    set_active_heading();
    if (headings.length === 0) {
      if (warnOnEmpty) {
        console.warn(`svelte-toc found no headings for headingSelector='${headingSelector}'. ${autoHide ? `Hiding` : `Showing empty`} table of contents.`);
      }
      if (autoHide)
        $$invalidate(3, hide = true);
    } else if (hide && autoHide) {
      $$invalidate(3, hide = false);
    }
  }
  requery_headings();
  onMount(() => {
    if (typeof pageBody === `string`) {
      $$invalidate(21, pageBody = document.querySelector(pageBody));
      if (!pageBody) {
        throw new Error(`Could not find page body element: ${pageBody}`);
      }
    }
    const mutation_observer = new MutationObserver(requery_headings);
    mutation_observer.observe(pageBody, { childList: true, subtree: true });
    return () => mutation_observer.disconnect();
  });
  function set_active_heading() {
    let idx = headings.length;
    while (idx--) {
      const { top } = headings[idx].getBoundingClientRect();
      if (top < activeHeadingScrollOffset || idx === 0) {
        $$invalidate(1, activeHeading = headings[idx]);
        $$invalidate(20, activeTocLi = tocItems[idx]);
        clearTimeout(scroll_id);
        scroll_id = window.setTimeout(
          () => {
            var _a;
            if (keepActiveTocItemInView && activeTocLi) {
              (_a = nav.scrollTo) == null ? void 0 : _a.call(nav, {
                top: (activeTocLi == null ? void 0 : activeTocLi.offsetTop) - nav.offsetHeight / 2,
                behavior: `smooth`
              });
            }
          },
          50
        );
        return;
      }
    }
  }
  const handler = (node) => (event) => {
    if (event instanceof KeyboardEvent && ![`Enter`, ` `].includes(event.key))
      return;
    $$invalidate(4, open = false);
    node.scrollIntoView({ behavior: scrollBehavior, block: `start` });
    const id = getHeadingIds && getHeadingIds(node);
    if (id)
      history.replaceState({}, ``, `#${id}`);
    if (flashClickedHeadingsFor) {
      node.classList.add(`toc-clicked`);
      setTimeout(() => node.classList.remove(`toc-clicked`), flashClickedHeadingsFor);
    }
  };
  const writable_props = [
    "activeHeading",
    "activeHeadingScrollOffset",
    "activeTocLi",
    "breakpoint",
    "desktop",
    "flashClickedHeadingsFor",
    "getHeadingIds",
    "getHeadingLevels",
    "getHeadingTitles",
    "headings",
    "headingSelector",
    "hide",
    "autoHide",
    "keepActiveTocItemInView",
    "minItems",
    "open",
    "openButtonLabel",
    "pageBody",
    "scrollBehavior",
    "title",
    "titleTag",
    "tocItems",
    "warnOnEmpty",
    "blurParams"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<Toc> was created with unknown prop '${key}'`);
  });
  function onwindowresize() {
    $$invalidate(12, window_width = window_1.innerWidth);
  }
  const click_handler = () => $$invalidate(4, open = true);
  function li_binding($$value, idx) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tocItems[idx] = $$value;
      $$invalidate(5, tocItems);
    });
  }
  function nav_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      nav = $$value;
      $$invalidate(15, nav);
    });
  }
  function aside_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      aside = $$value;
      $$invalidate(14, aside);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("activeHeading" in $$props2)
      $$invalidate(1, activeHeading = $$props2.activeHeading);
    if ("activeHeadingScrollOffset" in $$props2)
      $$invalidate(22, activeHeadingScrollOffset = $$props2.activeHeadingScrollOffset);
    if ("activeTocLi" in $$props2)
      $$invalidate(20, activeTocLi = $$props2.activeTocLi);
    if ("breakpoint" in $$props2)
      $$invalidate(23, breakpoint = $$props2.breakpoint);
    if ("desktop" in $$props2)
      $$invalidate(2, desktop = $$props2.desktop);
    if ("flashClickedHeadingsFor" in $$props2)
      $$invalidate(24, flashClickedHeadingsFor = $$props2.flashClickedHeadingsFor);
    if ("getHeadingIds" in $$props2)
      $$invalidate(25, getHeadingIds = $$props2.getHeadingIds);
    if ("getHeadingLevels" in $$props2)
      $$invalidate(26, getHeadingLevels = $$props2.getHeadingLevels);
    if ("getHeadingTitles" in $$props2)
      $$invalidate(6, getHeadingTitles = $$props2.getHeadingTitles);
    if ("headings" in $$props2)
      $$invalidate(0, headings = $$props2.headings);
    if ("headingSelector" in $$props2)
      $$invalidate(27, headingSelector = $$props2.headingSelector);
    if ("hide" in $$props2)
      $$invalidate(3, hide = $$props2.hide);
    if ("autoHide" in $$props2)
      $$invalidate(28, autoHide = $$props2.autoHide);
    if ("keepActiveTocItemInView" in $$props2)
      $$invalidate(29, keepActiveTocItemInView = $$props2.keepActiveTocItemInView);
    if ("minItems" in $$props2)
      $$invalidate(7, minItems = $$props2.minItems);
    if ("open" in $$props2)
      $$invalidate(4, open = $$props2.open);
    if ("openButtonLabel" in $$props2)
      $$invalidate(8, openButtonLabel = $$props2.openButtonLabel);
    if ("pageBody" in $$props2)
      $$invalidate(21, pageBody = $$props2.pageBody);
    if ("scrollBehavior" in $$props2)
      $$invalidate(30, scrollBehavior = $$props2.scrollBehavior);
    if ("title" in $$props2)
      $$invalidate(9, title = $$props2.title);
    if ("titleTag" in $$props2)
      $$invalidate(10, titleTag = $$props2.titleTag);
    if ("tocItems" in $$props2)
      $$invalidate(5, tocItems = $$props2.tocItems);
    if ("warnOnEmpty" in $$props2)
      $$invalidate(31, warnOnEmpty = $$props2.warnOnEmpty);
    if ("blurParams" in $$props2)
      $$invalidate(11, blurParams = $$props2.blurParams);
    if ("$$scope" in $$props2)
      $$invalidate(32, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    blur,
    MenuIcon: MenuIcon_default,
    activeHeading,
    activeHeadingScrollOffset,
    activeTocLi,
    breakpoint,
    desktop,
    flashClickedHeadingsFor,
    getHeadingIds,
    getHeadingLevels,
    getHeadingTitles,
    headings,
    headingSelector,
    hide,
    autoHide,
    keepActiveTocItemInView,
    minItems,
    open,
    openButtonLabel,
    pageBody,
    scrollBehavior,
    title,
    titleTag,
    tocItems,
    warnOnEmpty,
    blurParams,
    window_width,
    aside,
    nav,
    scroll_id,
    close,
    requery_headings,
    set_active_heading,
    handler,
    levels,
    minLevel
  });
  $$self.$inject_state = ($$props2) => {
    if ("activeHeading" in $$props2)
      $$invalidate(1, activeHeading = $$props2.activeHeading);
    if ("activeHeadingScrollOffset" in $$props2)
      $$invalidate(22, activeHeadingScrollOffset = $$props2.activeHeadingScrollOffset);
    if ("activeTocLi" in $$props2)
      $$invalidate(20, activeTocLi = $$props2.activeTocLi);
    if ("breakpoint" in $$props2)
      $$invalidate(23, breakpoint = $$props2.breakpoint);
    if ("desktop" in $$props2)
      $$invalidate(2, desktop = $$props2.desktop);
    if ("flashClickedHeadingsFor" in $$props2)
      $$invalidate(24, flashClickedHeadingsFor = $$props2.flashClickedHeadingsFor);
    if ("getHeadingIds" in $$props2)
      $$invalidate(25, getHeadingIds = $$props2.getHeadingIds);
    if ("getHeadingLevels" in $$props2)
      $$invalidate(26, getHeadingLevels = $$props2.getHeadingLevels);
    if ("getHeadingTitles" in $$props2)
      $$invalidate(6, getHeadingTitles = $$props2.getHeadingTitles);
    if ("headings" in $$props2)
      $$invalidate(0, headings = $$props2.headings);
    if ("headingSelector" in $$props2)
      $$invalidate(27, headingSelector = $$props2.headingSelector);
    if ("hide" in $$props2)
      $$invalidate(3, hide = $$props2.hide);
    if ("autoHide" in $$props2)
      $$invalidate(28, autoHide = $$props2.autoHide);
    if ("keepActiveTocItemInView" in $$props2)
      $$invalidate(29, keepActiveTocItemInView = $$props2.keepActiveTocItemInView);
    if ("minItems" in $$props2)
      $$invalidate(7, minItems = $$props2.minItems);
    if ("open" in $$props2)
      $$invalidate(4, open = $$props2.open);
    if ("openButtonLabel" in $$props2)
      $$invalidate(8, openButtonLabel = $$props2.openButtonLabel);
    if ("pageBody" in $$props2)
      $$invalidate(21, pageBody = $$props2.pageBody);
    if ("scrollBehavior" in $$props2)
      $$invalidate(30, scrollBehavior = $$props2.scrollBehavior);
    if ("title" in $$props2)
      $$invalidate(9, title = $$props2.title);
    if ("titleTag" in $$props2)
      $$invalidate(10, titleTag = $$props2.titleTag);
    if ("tocItems" in $$props2)
      $$invalidate(5, tocItems = $$props2.tocItems);
    if ("warnOnEmpty" in $$props2)
      $$invalidate(31, warnOnEmpty = $$props2.warnOnEmpty);
    if ("blurParams" in $$props2)
      $$invalidate(11, blurParams = $$props2.blurParams);
    if ("window_width" in $$props2)
      $$invalidate(12, window_width = $$props2.window_width);
    if ("aside" in $$props2)
      $$invalidate(14, aside = $$props2.aside);
    if ("nav" in $$props2)
      $$invalidate(15, nav = $$props2.nav);
    if ("scroll_id" in $$props2)
      scroll_id = $$props2.scroll_id;
    if ("levels" in $$props2)
      $$invalidate(13, levels = $$props2.levels);
    if ("minLevel" in $$props2)
      $$invalidate(16, minLevel = $$props2.minLevel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*headings, getHeadingLevels*/
    67108865) {
      $:
        $$invalidate(13, levels = headings.map(getHeadingLevels));
    }
    if ($$self.$$.dirty[0] & /*levels*/
    8192) {
      $:
        $$invalidate(16, minLevel = Math.min(...levels));
    }
    if ($$self.$$.dirty[0] & /*window_width, breakpoint*/
    8392704) {
      $:
        $$invalidate(2, desktop = window_width > breakpoint);
    }
  };
  return [
    headings,
    activeHeading,
    desktop,
    hide,
    open,
    tocItems,
    getHeadingTitles,
    minItems,
    openButtonLabel,
    title,
    titleTag,
    blurParams,
    window_width,
    levels,
    aside,
    nav,
    minLevel,
    close,
    set_active_heading,
    handler,
    activeTocLi,
    pageBody,
    activeHeadingScrollOffset,
    breakpoint,
    flashClickedHeadingsFor,
    getHeadingIds,
    getHeadingLevels,
    headingSelector,
    autoHide,
    keepActiveTocItemInView,
    scrollBehavior,
    warnOnEmpty,
    $$scope,
    slots,
    onwindowresize,
    click_handler,
    li_binding,
    nav_1_binding,
    aside_1_binding
  ];
}
var Toc = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        activeHeading: 1,
        activeHeadingScrollOffset: 22,
        activeTocLi: 20,
        breakpoint: 23,
        desktop: 2,
        flashClickedHeadingsFor: 24,
        getHeadingIds: 25,
        getHeadingLevels: 26,
        getHeadingTitles: 6,
        headings: 0,
        headingSelector: 27,
        hide: 3,
        autoHide: 28,
        keepActiveTocItemInView: 29,
        minItems: 7,
        open: 4,
        openButtonLabel: 8,
        pageBody: 21,
        scrollBehavior: 30,
        title: 9,
        titleTag: 10,
        tocItems: 5,
        warnOnEmpty: 31,
        blurParams: 11
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toc",
      options,
      id: create_fragment2.name
    });
  }
  get activeHeading() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeHeading(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeHeadingScrollOffset() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeHeadingScrollOffset(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeTocLi() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeTocLi(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get breakpoint() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set breakpoint(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get desktop() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set desktop(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flashClickedHeadingsFor() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flashClickedHeadingsFor(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getHeadingIds() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getHeadingIds(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getHeadingLevels() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getHeadingLevels(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getHeadingTitles() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getHeadingTitles(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headings() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headings(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headingSelector() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headingSelector(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hide() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hide(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoHide() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoHide(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keepActiveTocItemInView() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keepActiveTocItemInView(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minItems() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minItems(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openButtonLabel() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openButtonLabel(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageBody() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageBody(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollBehavior() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollBehavior(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleTag() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleTag(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tocItems() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tocItems(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnOnEmpty() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnOnEmpty(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blurParams() {
    throw new Error_1("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blurParams(value) {
    throw new Error_1("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toc_default = Toc;
export {
  MenuIcon_default as MenuIcon,
  Toc_default as Toc,
  Toc_default as default
};
//# sourceMappingURL=svelte-toc.js.map
